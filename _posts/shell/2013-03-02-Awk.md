---
layout: post
title: 文本处理神器sed与awk命令使用(续)
category: shell
tags: [shell, sed, awk]
keywords: shell, sed, awk
---

上一篇[传送门](http://gayyzxyx.github.com/shell/2013/02/24/Sed-And-Awk/)

## 概述：
awk功能与sed相似，都是处理文本的工具，但是awk的强大之处在于借助强大的语法支持处理格式化的文本，在处理没有规律的文本上面不及sed方便，术业有专攻吧。

## awk编程模型:

awk不能看作是一个shell命令了，更应该是一门编程语言。awk程序由一个主输入循环维持，其反复执行直到终止条件被触发。幸运的是awk的主循环框架无需我们去编写，已经搭建好了，我们只需要将写好的代码嵌入到循环框架中执行。awk有两个特殊的字段：BEGIN和END，BEGIN在主输入循环之前执行，即在未读取输入文件之前执行，END则恰好相反。总体看，awk程序的执行分为三个阶段：读输入文件之前的执行代码段（由BEGIN关键字标识）、读取输入文件时的执行代码段、读取输入文件之后的执行代码段（由END关键字标志）。

## awk的调用方法：
调用awk的方法与调用sed类似，也有三种方式：

1\.在shell命令行输入命令调用awk，格式为	

	awk [-F 域分隔符] 'awk程序段' 输入文件   #需要用单引号将awk程序段引起来

2\.将awk程序段插入脚本文件，然后通过awk命令调用它，格式为

	awk -f awk脚本文件 输入文件     #同sed命令类似也是通过-f选项表示调用脚本文件

3\.将sed命令插入脚本文件之后，最常用的方法是设置改脚本可执行，然后直接直接执行该脚本文件，格式为

	./awk脚本文件 输入文件     #同样以#/awk路径来开头

### 1\.awk模式匹配

任何awk语句都是由模式(pattern)和动作(action)构成，模式测试输入行是否需要执行动作的规则(决定动作何时触发和触发事件)，动作是包含语句、函数和表达式的执行过程(执行对输入行的处理)，awk不仅支持所有正则表达式的元字符还支持"?"和"+"两个扩展元字符，而grep和sed并不支持，看awk的三种调用方法。

	root@core /home/awk# awk '/^$/{print "this is a blank line."}' input    #方法一调用awk打印空白行
	this is a blank line.
	this is a blank line.
	this is a blank line.

	root@core /home/awk# cat > scr.awk   #创建scr.awk，执行命令
	/^$/{print "this is a blank line."}
	root@core /home/awk# awk -f scr.awk input   #方法二调用awk打印空白行
	this is a blank line.
	this is a blank line.
	this is a blank line.

	root@core /home/awk# cat  scr1.awk      #创建脚本
	#!/usr/bin/awk -f
	/^$/{print "this is a blank line."}
	root@core /home/awk# chmod u+x scr1.awk    #赋予可执行权限
	root@core /home/awk# ./scr1.awk input     #方法三调用awk打印空白行
	this is a blank line.
	this is a blank line.
	this is a blank line.

### 2\.记录和域

awk认为输入文件是结构化的，将每个输入行定义为记录，行中每一个字符串定义为域，域之间用空格、tab键或者其他符号进行分割。awk定义$来指定执行动作的域，如$1表示第一个域，$2表示第二个，$0则表示所有的域。有一个stu记录了学生信息，有四个域，分别用空格、tab、tab隔开如下：

	root@core /home/awk# awk '{print $2,$1,$3,$4}' stu   #依次打印第二个。第一个、第三个、第四个域
	Hao Li njue 025-83481010
	Ju Zhang nju 025-83466534
	Bin Wang seu 025-83494883
	Lin Zhu njupt 025-83680010

	root@core /home/awk# awk '{print $0}' stu         #$0表示打印所有域
	Li Hao  njue    025-83481010
	Zhang Ju        nju     025-83466534
	Wang Bin        seu     025-83494883
	Zhu Lin njupt   025-83680010

域操作符后面可以跟变量或者运算表达式，如下：

	root@core /home/awk# awk 'BEGIN {one=1;two=2}{print $(one+two)}' stu   #打印第三个域
	njue
	nju
	seu
	njupt

可以用awk的`-F`选项来改变分隔符，awk的默认设置的分隔符是空格键，而tab键是被当做连续的空格符来处理。

	root@core /home/awk# awk -F"\t" '{print $3}' stu    #此时的第三个域则是电话号码那列
	025-83481010
	025-83466534
	025-83494883
	025-83680010

awk还可以有另外一种方式来改变分隔符，那就是awk的环境变量FS，通过在BEGIN字段中设置FS值来改变分隔符。将stu记录中的tab制表符换成逗号

	root@core /home/awk# sed 's/\t/,/g' stu > stu1
	root@core /home/awk# mv stu1 stu
	root@core /home/awk# awk 'BEGIN{FS=","}{print $0}' stu              #打印替换后的结果
	Li Hao,njue,025-83481010
	Zhang Ju,nju,025-83466534
	Wang Bin,seu,025-83494883
	Zhu Lin,njupt,025-83680010

另外，可以利用正则表达式将分隔符设置为多个字符，如下:
(1)FS="\t"
(2)FS="\t+"
对于记录 wza\t\tcq，第一种将会把该记录解析为三个域：wza、空域、cq，第二种将其解析为两个域：wza和cq

### 3\.关系和布尔运算符

awk定义了一组关系运算符用于awk模式匹配，如下表：

<table class="table table-bordered table-striped">
    <tr><td>运算符</td><td>意义</td></tr>
    <tr><td>&lt;</td><td>小于</td></tr>
    <tr><td>></td><td>大于</td></tr>
    <tr><td>&lt;=</td><td>小于等于</td></tr>
    <tr><td>>=</td><td>大于等于</td></tr>
    <tr><td>==</td><td>等于</td></tr>
    <tr><td>!=</td><td>不等于</td></tr>
    <tr><td>~</td><td>匹配正则表达式</td></tr>
    <tr><td>!~</td><td>不匹配正则表达式</td></tr>
</table>

在/etc/passwd文件中存放了用户关键信息，以这个文件作为输入文件：

	root@core /home/awk# awk 'BEGIN {FS=":"} $1~/root/' /etc/passwd   #在第一个域中找出包含root关键字的记录
	root:x:0:0:root:/root:/bin/bash
	
awk在进行匹配的时候，常常使用到条件语句，awk的条件语句跟C语言的类似，有if、if/else、if/else else语句，如要匹配第三个域小于第四个的记录：

	root@core /home/awk# awk 'BEGIN {FS=":"} {if($3<$4) print $0} /etc/passwd

### 9\.条件语句和循环语句

awk的条件语句和循环语句的语法跟C语言的完全一样，有如下形式：

	if (条件表达式)
		动作1
	else
		动作2

	if(x==y) print x
	if(x~/正则表达式/) print x
	#也可以while或者do{}while
	while(条件表达式)
		动作
	#还可以for循环
	for(初值，计数器，计数器变化)
		动作

### 10\.数组

awk的数组的形式跟C语言的一样，但是awk数组无需定义数组类型和大小，可以直接赋值使用，基本格式为:
	
	array[index]=value

1\.关联数组

关联数组的意思是数组的索引既可以是字符串也可以是数字。在大部分编程语言中数组的索引只能是数字，而awk的不是这样。安维卡的所有数组都是关联数组，这是awk数组和其他大部分编程语言的数组的区别。

	root@core /home/awk# awk 'BEGIN{data[10.15]="1200";CONVFMT="%d";printf("<%s>",ta[10.15])}'   #字符串和数字是严格区分的
	<>

awk定义了一种特别的for循环来访问关联数组，array是定义的数组名，variable是任意指定的变量，

	for(variable in array)
		do something with array[variable]

关键字in也可以用在条件表达式中判断元素是否在数组中，如下：

	index in array

如果array[index]存在，返回1，否则返回0,如下

	root@core /home/awk# awk 'BEGIN{data[10.15]="1200";if("10.15" in data) print "found element!"}'
	found element!

2\.split函数

split函数的返回值是数组的大小，如下：

	root@core /home/awk# awk 'BEGIN{print split("abc/def/xyz",str,"/")}'    #将字符串abc/def/xyz分开，并存在str中
	3
	root@core /home/awk# awk 'BEGIN{split("abc/def/xyz",str,"/");for(i in str) print str[i]}'  #分别打印出来如下
	abc
	def
	xyz

3\.数组形式的系统变量

awk系统变量中有两个变量是以数组的形式提供的：`ARGV`和`ENVIRON`，ARGC是ARGV中数组中元素的个数，与C语言一样，从ARGV[0]开始到ARGV[ARGC-1]结束，如下：

	root@core /home/awk# cat > argv.awk
	BEGIN{for(x=0;x<ARGC;x++)
	print ARGV[x]
	print ARGC
	}
	root@core /home/awk# awk -f argv.awk xyz n=99 "hello world"    #xyz,n,hello world都是参数，可以看到awk[0]存的是awk,-f选项不在ARGV中，一般来说当不是执行脚本文件的时候，ARGC=2，如果没有输入文件，ARGC=1
	awk
	xyz
	n=99
	hello world
	4

如果要查找文件中内容，比如我们输入学生名字查找出学生的电话号码，可以如下：

	#!/usr/bin/awk -f               #findphone.awk的脚本
	BEGIN{FS=",";
		if(ARGC>2){
			#判断是否已经输入姓名
			name=ARGV[1];
			delete ARGV[1]}
		else{
				while(!name){print "please enter a name";
				getline name< "-"}
			}
	}
	$1 ~name {print $1,$3}
	root@core /home/awk# ./findphone.awk Zhu stu
	Zhu Lin 025-83680010
	root@core /home/awk# ./findphone.awk stu
	please enter a name
	Zhu
	Zhu Lin 025-83680010

ENVIRON变量存储了LINUX系统中的环境变量，如下可以打印出系统中ENVIRON数组中所有内容：

	root@core /home/awk# awk 'BEGIN {for (i in ENVIRON) print i "=" ENVIRON[i]}'
	SSH_CLIENT=192.168.115.1 49633 22
	EDITOR=vim
	HOME=/root
	PAGER=less -X -R -F
	TERM=xterm
	LESSOPEN=| /usr/bin/lesspipe %s
	LANGUAGE=en_US.UTF-8
	LC_ALL=C
	SHELL=/bin/bash
	OLDPWD=/root
	USER=root
	_=/usr/bin/awk
	SHLVL=1

ENVIRON索引的是环境变量名，因此也可以通过环境变量名得到其值：

	root@core /home/awk# awk 'BEGIN{print ENVIRON["HOME"]}'
	/root

最后看一个排序，对输入数组data:4,90,6.9,8,10,1,60,7.8,9.3进行排序，结合数组和逻辑控制，采用简单冒泡排序：

	#!/usr/bin/awk -f
	BEGIN {FS=","} {
		for(i=1;i<NF;i++){
			k=i
		for(j=i+1;j<=NF;j++)
			if($j<$k) k=j
				temp=$i;$i=$k;$k=temp;}
		print $0
	}
	root@core /home/awk# ./sort.awk  data   #排序结果
	1 4 6.9 7.8 8 9.3 10 60 90



