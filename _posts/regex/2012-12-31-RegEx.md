---
layout: post
title: RegEx
category: shell
tags: [shell]
keywords: regex
---

正则表达式用途广泛，在字符串匹配上功不可没，上学时候学了都忘了，只好操笔记下。在学习正则表达式的过程中少不了神器[Regex Tester](http://deerchao.net/tools/regex_tester/regextester.zip),边学边练习。

### 元字符

正则表达式中常用几种元字符

<table class="table table-bordered table-striped">
    <tr><td>元字符</td><td>说明</td></tr>
    <tr><td>.</td><td>匹配除换行符以外的所有字符</td></tr>
    <tr><td>\w</td><td>匹配字母、数字、下划线、汉字</td></tr>
    <tr><td>\s</td><td>匹配任意空白符</td></tr>
    <tr><td>\d</td><td>匹配数字</td></tr>
    <tr><td>\b</td><td>匹配单词的开始或者结束</td></tr>
    <tr><td>^</td><td>匹配字符串的开始</td></tr>
    <tr><td>$</td><td>匹配字符串的结束</td></tr>
</table>

在查找元字符本身的时候需要字符转义，例如查找`.`或者`*`或者`\`，需要加上转义字符`\`，即正则表达式：`\*`，`\*`，`\\`。如果要正确匹配5位到8位的QQ号码，可以写成`\d{5,8}`，匹配过程中需要用到数量的限定，正则表达式中常用的数量限定如下：

<table class="table table-bordered table-striped">
    <tr><td>代码</td><td>说明</td></tr>
    <tr><td>*</td><td>重复0次到很多次</td></tr>
    <tr><td>+</td><td>重复一次到很多次</td></tr>
    <tr><td>？</td><td>重复0次或者1次</td></tr>
    <tr><td>{n}</td><td>重复n次</td></tr>
    <tr><td>{n,m}</td><td>重复n次到m次</td></tr>
    <tr><td>{n,}</td><td>重复n次到很多次</td></tr>
</table>

比如要匹配一个电话号码，有下面三种格式：(010)66666666、010666666、010-666666。可以预见开头要么出现(要么不出现，可以这样判断

    \(?0\d{2}[)-]?\d{8}

，可以匹配出以上三种情形，但是如果号码是这样:(01099999999或者这样010)99999999也匹配成功了就显然有问题，这时需要加入分支判断`|`，因为刚才没有判断`(`与`)`是成对出现的，可以这样

    ^0\d{2}[-]?\d{8}|\(0\d{2}\)\d{8}

一定要注意加上`^`从字符串开头匹配，不然出现(010666666的时候，检测到(后面的内容也会匹配成功。**在进行分支判断的时候要注意分支条件的顺序**，因为`|`这个符号就跟逻辑表达式的`||`类似，从左到右判断，只要一个满足就返回了true。

### 分组

我们要重复单个字符好办，用上面提供的重复限制就可以搞定，但是如果要重复的是一个字符串呢？这时候需要用到分组。简单的一个IP地址192.168.1.1，这个地址分为四段，前三段都是一样，一组一位到三位的数字加一个`.组成`即`\d{1,3}\.`，最后一组是`\d{1,3}`，所以关于IP地址的正则表达式可以简单的写成、

    (\d{1,3}\.){3}\d{1,3}

`{3}`表示把前面括号的重复三次。但是IP地址每一级的范围是0-255,所以上面那样判断是有问题的，但是正则表达式不能数学计算，所以只好用分支判断分情况考虑，如下：

    ^(2[0-4]\d|25[0-5][01]?|([01]?\d\d?)\.){3}(2[0-4]\d|25[0-5][01]?|[01]?\d\d?)$

这时候有一点需要注意的是`2[0-4]\d|25[0-5][01]?|([01]?\d\d?`中的`([01]?\d\d?`分支不能放在最前面，不然可能会会导致错误判断（在没有限制字符串的结束位置的时候），因为`([01]?\d\d?`的作用是判断一位两位数的情况和三位数但是是0或者1开头的情况，如果放最前面就会造成如果,192.168.1.248，最后匹配到的结果是192.168.1.24，这显然是不和条件的。所以分支判断位置很重要。

### 反义

顾名思义，反义的意思就是匹配所给规则之外的字符。关于反义元字符的有下面几种：

<table class="table table-bordered table-striped">
    <tr><td>字符</td><td>说明</td></tr>
    <tr><td>\W</td><td>匹配任意不是字母数字下划线汉字的字符</td></tr>
    <tr><td>\S</td><td>匹配任意不是空白符的字符</td></tr>
    <tr><td>\D</td><td>匹配任意不是数字的字符</td></tr>
    <tr><td>\B</td><td>匹配任意不是单词开头或者结束的位置</td></tr>
    <tr><td>{^m}</td><td>匹配除了m之外的任意字符</td></tr>
    <tr><td>{^mnp}</td><td>匹配除了不是mnp这几个字符以外的任意字符</td></tr>
</table>

### 后向引用

使用情形：找出所有重复单词。
使用小括号指定一个子表达式作为一个分组，在后面程序中可以引用这个子表达式匹配，默认的每一组子表达式会有一个编号从1开始。比如要匹配重复单词hello hello，可以这样写正则表达式

    \b(\w+)\b\s+\1\b  

又如要找出以hello开始并且以hello结束的字符串：

    \b(\w+)\b\s+(\w+\s+)*(\1\b)

上面`\1`就表示的是第一个分组。关于组名可以自己指定，需要使用这样的语法：`(?<name>\w+)`,反向捕获的时候使用`\k<name>`，所以上面的例子可以换成

    \b(?<name>\w+)\b\s+(\w+\s+)*(\k<name>\b)



