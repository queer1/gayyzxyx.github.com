---
layout: post
title: RegEx
category: shell
tags: [shell]
keywords: regex
---

正则表达式用途广泛，在字符串匹配上功不可没，上学时候学了都忘了，只好操笔记下。在学习正则表达式的过程中少不了神器[Regex Tester](http://deerchao.net/tools/regex_tester/regextester.zip),边学边练习。

### 元字符

正则表达式中常用几种元字符

<table class="table table-bordered table-striped">
    <tr><td>元字符</td><td>说明</td></tr>
    <tr><td>.</td><td>匹配除换行符以外的所有字符</td></tr>
    <tr><td>\w</td><td>匹配字母、数字、下划线、汉字</td></tr>
    <tr><td>\s</td><td>匹配任意空白符</td></tr>
    <tr><td>\d</td><td>匹配数字</td></tr>
    <tr><td>\b</td><td>匹配单词的开始或者结束</td></tr>
    <tr><td>^</td><td>匹配字符串的开始</td></tr>
    <tr><td>$</td><td>匹配字符串的结束</td></tr>
</table>

在查找元字符本身的时候需要字符转义，例如查找`.`或者`*`或者`\`，需要加上转义字符`\`，即正则表达式：`\*`，`\*`，`\\`。如果要正确匹配5位到8位的QQ号码，可以写成`\d{5,8}`，匹配过程中需要用到数量的限定，正则表达式中常用的数量限定如下：

<table class="table table-bordered table-striped">
    <tr><td>代码</td><td>说明</td></tr>
    <tr><td>*</td><td>重复0次到很多次</td></tr>
    <tr><td>+</td><td>重复一次到很多次</td></tr>
    <tr><td>？</td><td>重复0次或者1次</td></tr>
    <tr><td>{n}</td><td>重复n次</td></tr>
    <tr><td>{n,m}</td><td>重复n次到m次</td></tr>
    <tr><td>{n,}</td><td>重复n次到很多次</td></tr>
</table>

比如要匹配一个电话号码，有下面三种格式：(010)66666666、010666666、010-666666。可以预见开头要么出现(要么不出现，可以这样判断

    \(?0\d{2}[)-]?\d{8}

，可以匹配出以上三种情形，但是如果号码是这样:(01099999999或者这样010)99999999也匹配成功了就显然有问题，这时需要加入分支判断`|`，因为刚才没有判断`(`与`)`是成对出现的，可以这样

    ^0\d{2}[-]?\d{8}|\(0\d{2}\)\d{8}

一定要注意加上`^`从字符串开头匹配，不然出现(010666666的时候，检测到(后面的内容也会匹配成功。**在进行分支判断的时候要注意分支条件的顺序**，因为`|`这个符号就跟逻辑表达式的`||`类似，从左到右判断，只要一个满足就返回了true。

### 分组

我们要重复单个字符好办，用上面提供的重复限制就可以搞定，但是如果要重复的是一个字符串呢？这时候需要用到分组。简单的一个IP地址192.168.1.1，这个地址分为四段，前三段都是一样，一组一位到三位的数字加一个`.组成`即`\d{1,3}\.`，最后一组是`\d{1,3}`，所以关于IP地址的正则表达式可以简单的写成、

    (\d{1,3}\.){3}\d{1,3}

`{3}`表示把前面括号的重复三次。但是IP地址每一级的范围是0-255,所以上面那样判断是有问题的，但是正则表达式不能数学计算，所以只好用分支判断分情况考虑，如下：

    ^(2[0-4]\d|25[0-5][01]?|([01]?\d\d?)\.){3}(2[0-4]\d|25[0-5][01]?|[01]?\d\d?)$

这时候有一点需要注意的是`2[0-4]\d|25[0-5][01]?|([01]?\d\d?`中的`([01]?\d\d?`分支不能放在最前面，不然可能会会导致错误判断（在没有限制字符串的结束位置的时候），因为`([01]?\d\d?`的作用是判断一位两位数的情况和三位数但是是0或者1开头的情况，如果放最前面就会造成如果,192.168.1.248，最后匹配到的结果是192.168.1.24，这显然是不和条件的。所以分支判断位置很重要。

### 反义

顾名思义，反义的意思就是匹配所给规则之外的字符。关于反义元字符的有下面几种：

<table class="table table-bordered table-striped">
    <tr><td>字符</td><td>说明</td></tr>
    <tr><td>\W</td><td>匹配任意不是字母数字下划线汉字的字符</td></tr>
    <tr><td>\S</td><td>匹配任意不是空白符的字符</td></tr>
    <tr><td>\D</td><td>匹配任意不是数字的字符</td></tr>
    <tr><td>\B</td><td>匹配任意不是单词开头或者结束的位置</td></tr>
    <tr><td>{^m}</td><td>匹配除了m之外的任意字符</td></tr>
    <tr><td>{^mnp}</td><td>匹配除了不是mnp这几个字符以外的任意字符</td></tr>
</table>

### 后向引用

使用情形：找出所有重复单词。
使用小括号指定一个子表达式作为一个分组，在后面程序中可以引用这个子表达式匹配，默认的每一组子表达式会有一个编号从1开始。比如要匹配重复单词hello hello，可以这样写正则表达式

    \b(\w+)\b\s+\1\b  

又如要找出以hello开始并且以hello结束的字符串：

    \b(\w+)\b\s+(\w+\s+)*(\1\b)

上面`\1`就表示的是第一个分组。关于组名可以自己指定，需要使用这样的语法：`(?<name>\w+)`,反向捕获的时候使用`\k<name>`，所以上面的例子可以换成

    \b(?<name>\w+)\b\s+(\w+\s+)*(\k<name>\b)

### 零宽断言

举个例子，在`i am laughing while you are crying`中找出以`ing`结尾的单词。如果不知道断言这回事可以写`\b\w+(ing\b)`来找出带`ing`的单词，但是现在是要找出ing之前的部分，这时候就需要断言的帮助了。

<table class="table table-bordered table-striped">
    <tr><td>(?=word)</td><td>匹配word之前的位置</td></tr>
    <tr><td>(?&lt;=word)</td><td>匹配word之后的位置</td></tr>
    <tr><td>(?!word)</td><td>匹配后面跟的不是word的位置</td></tr>
    <tr><td>(?&lt;!word)</td><td>匹配前面跟的不是word的位置</td></tr>
</table>

接着上例，我们可以找出以`ing`结尾的单词用`\b\w+(?=ing\b)`，结果是`laugh`,`cry`。再如要找出`la`所在单词之后的部分：`(?<=\bsm)\w+\b`,得到`ughing`。

**断言：正则表达式中的断言只是用来申明一个为真的事实，只有断言为真的时候才执行后面的匹配**。

### 负向零宽断言
`(?!word)`,断言此位置后面不能匹配表达式`word`,例如`\b((?!abc)\w)+\b`，匹配不包含连续字符串`abc`的字符串。于是同理，`(?<!word)`用来断言此位置前面不能匹配表达式`word`，`(?<![a-z])\d[7]`表示匹配一个开头不是小写字母的七位数字，如`S3456789`得到`3456789`.
在做网页内容抓取的时候经常会抓取一段HTML标签内的内容比如：

    <b> this is a demo</b>

我们要获取`this is a demo`，用零宽断言就可以解决。

    (?<=<(?<name>\w+)>)[\s\S]*(?=<\/\k<name>>)

其中`(?<=<>)`表示的是标签的第一个`<>`，表示匹配标签开始之后的位置，`<(?<name>\w+)>`表示的是标签名字,比如`<b>`，其中用到了后向引用，因为标签的收尾肯定是和标签头一样的。`\s\S`表示所有字符，是一个全集，`(?=<\/\k<name>>`中的`\k<name>`表示是对前面的`name`的引用，`\/`表示是对特殊字符`/`的转义。所以整个表达式的内容便是`<b></b>`之前的内容，不包含标签。

**需要转义的字符：**`* . ? + $ ^ [ ] ( ) { } | \ /`

### 贪婪匹配与懒惰匹配

给一个字符串`aababab`，表达式`a.*b`，得到的匹配结果是`aababab`，但是我们有时候只是想要一个更短的结果，让它一匹配成功就结束。最大匹配便是贪婪匹配，最小匹配便是懒惰匹配。关于懒惰限定符有如下几种：

<table class="table table-bordered table-striped">
    <tr><td>*？</td><td>重复任意次但尽可能少重复</td></tr>
    <tr><td>+?</td><td>重复一次或者任意次但尽可能少重复</td></tr>
    <tr><td>??</td><td>重复0次或1次，但尽可能少重复</td></tr>
    <tr><td>{n,m}?</td><td>重复n次到m次，但尽可能少重复</td></tr>
    <tr><td>{n,}?</td><td>重复n次到m更多次，但尽可能少重复</td></tr>
</table>

所以表达式为`a.*?b`的话，结果便是`aab`和`ab`。

**2012结束了**
